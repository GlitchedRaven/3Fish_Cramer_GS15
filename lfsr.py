class LFSR:
    def __init__(self, memory_size, xor_points_list=[]):
        self._memory = [0 for i in list(range(memory_size))]
        self._xor_map = xor_points_list
        self._output = []

    def display_memory(self):
        print(self._memory)

    def display_output(self):
        print(self._output)

    def start(self, iv=[1]):
        # Initialisation of the LFSR with chosen initialisation vector;
        # this verctor's size should be at most the LFSR's memory length

        if len(iv) < len(self._memory):
            iv.extend([0 for i in list(range(len(self._memory)-len(iv)))])
            self._memory = iv

        else:
            self._memory = iv[0:len(self._memory)-1]

    def rand_gen(self, rand_lenght, offset=0):
        # outputs the list of binary values generated by the LFSR,
        # rand_length is the size of the output and equals the number of rounds the LFSR performs
        # the offset is the number of first binary values generated by the LFSR to be left out of the output
        # it is equivalent of a cursor starting point
        number_rounds = rand_lenght + offset

        key_gen = []
        for round in list(range(number_rounds+1)):
            xor_res = 0
            #(self._memory)
            for term in self._xor_map:

                xor_res += self._memory[term-1]
                xor_res = xor_res%2
            self._output.append(xor_res)
            self._memory.append(xor_res)
            self._memory = self._memory[1:]

            if round > offset:
                key_gen.append(xor_res)

        return key_gen


    def clear(self):
        #clears the LFSR's memory
        self._memory = [0 for i in list(range(len(self._memory)-1))]
        self._output = []